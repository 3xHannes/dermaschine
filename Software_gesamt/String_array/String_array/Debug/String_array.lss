
String_array.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003a6  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stab         000009c0  00000000  00000000  000003fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  2 .stabstr      000001df  00000000  00000000  00000dbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_aranges 00000040  00000000  00000000  00000f9b  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000000da  00000000  00000000  00000fdb  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000009ac  00000000  00000000  000010b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002b4  00000000  00000000  00001a61  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000055d  00000000  00000000  00001d15  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000f0  00000000  00000000  00002274  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000286  00000000  00000000  00002364  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000018b  00000000  00000000  000025ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubtypes 00000057  00000000  00000000  00002775  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	6f c0       	rjmp	.+222    	; 0xe0 <__ctors_end>
   2:	76 c0       	rjmp	.+236    	; 0xf0 <__bad_interrupt>
   4:	75 c0       	rjmp	.+234    	; 0xf0 <__bad_interrupt>
   6:	74 c0       	rjmp	.+232    	; 0xf0 <__bad_interrupt>
   8:	73 c0       	rjmp	.+230    	; 0xf0 <__bad_interrupt>
   a:	72 c0       	rjmp	.+228    	; 0xf0 <__bad_interrupt>
   c:	71 c0       	rjmp	.+226    	; 0xf0 <__bad_interrupt>
   e:	70 c0       	rjmp	.+224    	; 0xf0 <__bad_interrupt>
  10:	6f c0       	rjmp	.+222    	; 0xf0 <__bad_interrupt>
  12:	6e c0       	rjmp	.+220    	; 0xf0 <__bad_interrupt>
  14:	6d c0       	rjmp	.+218    	; 0xf0 <__bad_interrupt>
  16:	6c c0       	rjmp	.+216    	; 0xf0 <__bad_interrupt>
  18:	6b c0       	rjmp	.+214    	; 0xf0 <__bad_interrupt>
  1a:	6a c0       	rjmp	.+212    	; 0xf0 <__bad_interrupt>
  1c:	69 c0       	rjmp	.+210    	; 0xf0 <__bad_interrupt>
  1e:	68 c0       	rjmp	.+208    	; 0xf0 <__bad_interrupt>
  20:	67 c0       	rjmp	.+206    	; 0xf0 <__bad_interrupt>
  22:	66 c0       	rjmp	.+204    	; 0xf0 <__bad_interrupt>
  24:	65 c0       	rjmp	.+202    	; 0xf0 <__bad_interrupt>

00000026 <getranke_namen>:
  26:	4e 00 59 00 60 00 66 00 6d 00 71 00 79 00 81 00     N.Y.`.f.m.q.y...
  36:	89 00 91 00 99 00 a1 00 a9 00 b1 00 b9 00 c1 00     ................
  46:	c9 00 ce 00 d5 00 da 00                             ........

0000004e <str0>:
  4e:	45 72 72 6f 72 20 32 30 31 34 00                    Error 2014.

00000059 <str1>:
  59:	41 73 62 61 63 68 00                                Asbach.

00000060 <str2>:
  60:	57 6f 64 6b 61 00                                   Wodka.

00000066 <str3>:
  66:	57 68 79 73 6b 69 00                                Whyski.

0000006d <str4>:
  6d:	52 75 6d 00                                         Rum.

00000071 <str5>:
  71:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

00000079 <str6>:
  79:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

00000081 <str7>:
  81:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

00000089 <str8>:
  89:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

00000091 <str9>:
  91:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

00000099 <str10>:
  99:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000000a1 <str11>:
  a1:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000000a9 <str12>:
  a9:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000000b1 <str13>:
  b1:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000000b9 <str14>:
  b9:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000000c1 <str15>:
  c1:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000000c9 <str16>:
  c9:	43 6f 6c 61 00                                      Cola.

000000ce <str17>:
  ce:	4f 2d 53 61 66 74 00                                O-Saft.

000000d5 <str18>:
  d5:	42 75 6c 6c 00                                      Bull.

000000da <str19>:
  da:	4c 65 6d 6f 6d 00                                   Lemom.

000000e0 <__ctors_end>:
  e0:	11 24       	eor	r1, r1
  e2:	1f be       	out	0x3f, r1	; 63
  e4:	cf e5       	ldi	r28, 0x5F	; 95
  e6:	d4 e0       	ldi	r29, 0x04	; 4
  e8:	de bf       	out	0x3e, r29	; 62
  ea:	cd bf       	out	0x3d, r28	; 61
  ec:	f4 d0       	rcall	.+488    	; 0x2d6 <main>
  ee:	59 c1       	rjmp	.+690    	; 0x3a2 <_exit>

000000f0 <__bad_interrupt>:
  f0:	87 cf       	rjmp	.-242    	; 0x0 <__vectors>

000000f2 <lcd_enable>:
 
////////////////////////////////////////////////////////////////////////////////
// Erzeugt einen Enable-Puls
static void lcd_enable( void )
{
    LCD_PORT |= (1<<LCD_EN);     // Enable auf 1 setzen
  f2:	95 9a       	sbi	0x12, 5	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f4:	85 e3       	ldi	r24, 0x35	; 53
  f6:	8a 95       	dec	r24
  f8:	f1 f7       	brne	.-4      	; 0xf6 <lcd_enable+0x4>
  fa:	00 00       	nop
    _delay_us( LCD_ENABLE_US );  // kurze Pause
    LCD_PORT &= ~(1<<LCD_EN);    // Enable auf 0 setzen
  fc:	95 98       	cbi	0x12, 5	; 18
}
  fe:	08 95       	ret

00000100 <lcd_out>:
// Sendet eine 4-bit Ausgabeoperation an das LCD
static void lcd_out( uint8_t data )
{
    data &= 0xF0;                       // obere 4 Bit maskieren
 
    LCD_PORT &= ~(0xF0>>(4-LCD_DB));    // Maske löschen
 100:	92 b3       	in	r25, 0x12	; 18
 102:	90 7f       	andi	r25, 0xF0	; 240
 104:	92 bb       	out	0x12, r25	; 18
    LCD_PORT |= (data>>(4-LCD_DB));     // Bits setzen
 106:	92 b3       	in	r25, 0x12	; 18
 108:	82 95       	swap	r24
 10a:	8f 70       	andi	r24, 0x0F	; 15
 10c:	98 2b       	or	r25, r24
 10e:	92 bb       	out	0x12, r25	; 18
    lcd_enable();
 110:	f0 df       	rcall	.-32     	; 0xf2 <lcd_enable>
}
 112:	08 95       	ret

00000114 <lcd_data>:
}
 
////////////////////////////////////////////////////////////////////////////////
// Sendet ein Datenbyte an das LCD
void lcd_data( uint8_t data )
{
 114:	1f 93       	push	r17
 116:	18 2f       	mov	r17, r24
    LCD_PORT |= (1<<LCD_RS);    // RS auf 1 setzen
 118:	94 9a       	sbi	0x12, 4	; 18
 
    lcd_out( data );            // zuerst die oberen, 
 11a:	f2 df       	rcall	.-28     	; 0x100 <lcd_out>
    lcd_out( data<<4 );         // dann die unteren 4 Bit senden
 11c:	81 2f       	mov	r24, r17
 11e:	82 95       	swap	r24
 120:	80 7f       	andi	r24, 0xF0	; 240
 122:	ee df       	rcall	.-36     	; 0x100 <lcd_out>
 124:	8a e7       	ldi	r24, 0x7A	; 122
 126:	8a 95       	dec	r24
 128:	f1 f7       	brne	.-4      	; 0x126 <lcd_data+0x12>
 12a:	00 c0       	rjmp	.+0      	; 0x12c <lcd_data+0x18>
 
    _delay_us( LCD_WRITEDATA_US );
}
 12c:	1f 91       	pop	r17
 12e:	08 95       	ret

00000130 <lcd_command>:
 
////////////////////////////////////////////////////////////////////////////////
// Sendet einen Befehl an das LCD
void lcd_command( uint8_t data )
{
 130:	1f 93       	push	r17
 132:	18 2f       	mov	r17, r24
    LCD_PORT &= ~(1<<LCD_RS);    // RS auf 0 setzen
 134:	94 98       	cbi	0x12, 4	; 18
 
    lcd_out( data );             // zuerst die oberen, 
 136:	e4 df       	rcall	.-56     	; 0x100 <lcd_out>
    lcd_out( data<<4 );           // dann die unteren 4 Bit senden
 138:	81 2f       	mov	r24, r17
 13a:	82 95       	swap	r24
 13c:	80 7f       	andi	r24, 0xF0	; 240
 13e:	e0 df       	rcall	.-64     	; 0x100 <lcd_out>
 140:	80 e7       	ldi	r24, 0x70	; 112
 142:	8a 95       	dec	r24
 144:	f1 f7       	brne	.-4      	; 0x142 <lcd_command+0x12>
 
    _delay_us( LCD_COMMAND_US );
}
 146:	1f 91       	pop	r17
 148:	08 95       	ret

0000014a <lcd_clear>:
 
////////////////////////////////////////////////////////////////////////////////
// Sendet den Befehl zur Löschung des Displays
void lcd_clear( void )
{
    lcd_command( LCD_CLEAR_DISPLAY );
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	f1 df       	rcall	.-30     	; 0x130 <lcd_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 14e:	8f e9       	ldi	r24, 0x9F	; 159
 150:	9f e0       	ldi	r25, 0x0F	; 15
 152:	01 97       	sbiw	r24, 0x01	; 1
 154:	f1 f7       	brne	.-4      	; 0x152 <lcd_clear+0x8>
 156:	00 c0       	rjmp	.+0      	; 0x158 <lcd_clear+0xe>
 158:	00 00       	nop
    _delay_ms( LCD_CLEAR_DISPLAY_MS );
}
 15a:	08 95       	ret

0000015c <lcd_init>:
{
    // verwendete Pins auf Ausgang schalten
    uint8_t pins = (0x0F << LCD_DB) |           // 4 Datenleitungen
                   (1<<LCD_RS) |                // R/S Leitung
                   (1<<LCD_EN);                 // Enable Leitung
    LCD_DDR |= pins;
 15c:	81 b3       	in	r24, 0x11	; 17
 15e:	8f 63       	ori	r24, 0x3F	; 63
 160:	81 bb       	out	0x11, r24	; 17
 
    // initial alle Ausgänge auf Null
    LCD_PORT &= ~pins;
 162:	82 b3       	in	r24, 0x12	; 18
 164:	80 7c       	andi	r24, 0xC0	; 192
 166:	82 bb       	out	0x12, r24	; 18
 168:	8f e2       	ldi	r24, 0x2F	; 47
 16a:	95 e7       	ldi	r25, 0x75	; 117
 16c:	01 97       	sbiw	r24, 0x01	; 1
 16e:	f1 f7       	brne	.-4      	; 0x16c <lcd_init+0x10>
 170:	00 c0       	rjmp	.+0      	; 0x172 <lcd_init+0x16>
 172:	00 00       	nop
 
    // warten auf die Bereitschaft des LCD
    _delay_ms( LCD_BOOTUP_MS );
 
    // Soft-Reset muss 3mal hintereinander gesendet werden zur Initialisierung
    lcd_out( LCD_SOFT_RESET );
 174:	80 e3       	ldi	r24, 0x30	; 48
 176:	c4 df       	rcall	.-120    	; 0x100 <lcd_out>
 178:	8f e0       	ldi	r24, 0x0F	; 15
 17a:	97 e2       	ldi	r25, 0x27	; 39
 17c:	01 97       	sbiw	r24, 0x01	; 1
 17e:	f1 f7       	brne	.-4      	; 0x17c <lcd_init+0x20>
 180:	00 c0       	rjmp	.+0      	; 0x182 <lcd_init+0x26>
 182:	00 00       	nop
    _delay_ms( LCD_SOFT_RESET_MS1 );
 
    lcd_enable();
 184:	b6 df       	rcall	.-148    	; 0xf2 <lcd_enable>
 186:	8f ec       	ldi	r24, 0xCF	; 207
 188:	97 e0       	ldi	r25, 0x07	; 7
 18a:	01 97       	sbiw	r24, 0x01	; 1
 18c:	f1 f7       	brne	.-4      	; 0x18a <lcd_init+0x2e>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <lcd_init+0x34>
 190:	00 00       	nop
    _delay_ms( LCD_SOFT_RESET_MS2 );
 
    lcd_enable();
 192:	af df       	rcall	.-162    	; 0xf2 <lcd_enable>
 194:	8f ec       	ldi	r24, 0xCF	; 207
 196:	97 e0       	ldi	r25, 0x07	; 7
 198:	01 97       	sbiw	r24, 0x01	; 1
 19a:	f1 f7       	brne	.-4      	; 0x198 <lcd_init+0x3c>
 19c:	00 c0       	rjmp	.+0      	; 0x19e <lcd_init+0x42>
 19e:	00 00       	nop
    _delay_ms( LCD_SOFT_RESET_MS3 );
 
    // 4-bit Modus aktivieren 
    lcd_out( LCD_SET_FUNCTION |
 1a0:	80 e2       	ldi	r24, 0x20	; 32
 1a2:	ae df       	rcall	.-164    	; 0x100 <lcd_out>
 1a4:	8f e0       	ldi	r24, 0x0F	; 15
 1a6:	97 e2       	ldi	r25, 0x27	; 39
 1a8:	01 97       	sbiw	r24, 0x01	; 1
 1aa:	f1 f7       	brne	.-4      	; 0x1a8 <lcd_init+0x4c>
 1ac:	00 c0       	rjmp	.+0      	; 0x1ae <lcd_init+0x52>
 1ae:	00 00       	nop
             LCD_FUNCTION_4BIT );
    _delay_ms( LCD_SET_4BITMODE_MS );
 
    // 4-bit Modus / 2 Zeilen / 5x7
    lcd_command( LCD_SET_FUNCTION |
 1b0:	88 e2       	ldi	r24, 0x28	; 40
 1b2:	be df       	rcall	.-132    	; 0x130 <lcd_command>
                 LCD_FUNCTION_4BIT |
                 LCD_FUNCTION_2LINE |
                 LCD_FUNCTION_5X7 );
 
    // Display ein / Cursor aus / Blinken aus
    lcd_command( LCD_SET_DISPLAY |
 1b4:	8c e0       	ldi	r24, 0x0C	; 12
 1b6:	bc df       	rcall	.-136    	; 0x130 <lcd_command>
                 LCD_DISPLAY_ON |
                 LCD_CURSOR_OFF |
                 LCD_BLINKING_OFF); 
 
    // Cursor inkrement / kein Scrollen
    lcd_command( LCD_SET_ENTRY |
 1b8:	86 e0       	ldi	r24, 0x06	; 6
 1ba:	ba df       	rcall	.-140    	; 0x130 <lcd_command>
                 LCD_ENTRY_INCREASE |
                 LCD_ENTRY_NOSHIFT );
 
    lcd_clear();
 1bc:	c6 df       	rcall	.-116    	; 0x14a <lcd_clear>
}
 1be:	08 95       	ret

000001c0 <lcd_home>:
 
////////////////////////////////////////////////////////////////////////////////
// Sendet den Befehl: Cursor Home
void lcd_home( void )
{
    lcd_command( LCD_CURSOR_HOME );
 1c0:	82 e0       	ldi	r24, 0x02	; 2
 1c2:	b6 df       	rcall	.-148    	; 0x130 <lcd_command>
 1c4:	8f e9       	ldi	r24, 0x9F	; 159
 1c6:	9f e0       	ldi	r25, 0x0F	; 15
 1c8:	01 97       	sbiw	r24, 0x01	; 1
 1ca:	f1 f7       	brne	.-4      	; 0x1c8 <lcd_home+0x8>
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <lcd_home+0xe>
 1ce:	00 00       	nop
    _delay_ms( LCD_CURSOR_HOME_MS );
}
 1d0:	08 95       	ret

000001d2 <lcd_setcursor>:
 
void lcd_setcursor( uint8_t x, uint8_t y )
{
    uint8_t data;
 
    switch (y)
 1d2:	62 30       	cpi	r22, 0x02	; 2
 1d4:	61 f0       	breq	.+24     	; 0x1ee <lcd_setcursor+0x1c>
 1d6:	63 30       	cpi	r22, 0x03	; 3
 1d8:	18 f4       	brcc	.+6      	; 0x1e0 <lcd_setcursor+0xe>
 1da:	61 30       	cpi	r22, 0x01	; 1
 1dc:	71 f4       	brne	.+28     	; 0x1fa <lcd_setcursor+0x28>
 1de:	05 c0       	rjmp	.+10     	; 0x1ea <lcd_setcursor+0x18>
 1e0:	63 30       	cpi	r22, 0x03	; 3
 1e2:	39 f0       	breq	.+14     	; 0x1f2 <lcd_setcursor+0x20>
 1e4:	64 30       	cpi	r22, 0x04	; 4
 1e6:	49 f4       	brne	.+18     	; 0x1fa <lcd_setcursor+0x28>
 1e8:	06 c0       	rjmp	.+12     	; 0x1f6 <lcd_setcursor+0x24>
    {
        case 1:    // 1. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE1 + x;
 1ea:	80 58       	subi	r24, 0x80	; 128
            break;
 1ec:	05 c0       	rjmp	.+10     	; 0x1f8 <lcd_setcursor+0x26>
 
        case 2:    // 2. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE2 + x;
 1ee:	80 54       	subi	r24, 0x40	; 64
            break;
 1f0:	03 c0       	rjmp	.+6      	; 0x1f8 <lcd_setcursor+0x26>
 
        case 3:    // 3. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE3 + x;
 1f2:	80 57       	subi	r24, 0x70	; 112
            break;
 1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <lcd_setcursor+0x26>
 
        case 4:    // 4. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE4 + x;
 1f6:	80 53       	subi	r24, 0x30	; 48
 
        default:
            return;                                   // für den Fall einer falschen Zeile
    }
 
    lcd_command( data );
 1f8:	9b df       	rcall	.-202    	; 0x130 <lcd_command>
 1fa:	08 95       	ret

000001fc <lcd_string>:
 
////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD
 
void lcd_string( const char *data )
{
 1fc:	cf 93       	push	r28
 1fe:	df 93       	push	r29
 200:	ec 01       	movw	r28, r24
    while( *data != '\0' )
 202:	88 81       	ld	r24, Y
 204:	88 23       	and	r24, r24
 206:	29 f0       	breq	.+10     	; 0x212 <lcd_string+0x16>
}
 
////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD
 
void lcd_string( const char *data )
 208:	21 96       	adiw	r28, 0x01	; 1
{
    while( *data != '\0' )
        lcd_data( *data++ );
 20a:	84 df       	rcall	.-248    	; 0x114 <lcd_data>
////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD
 
void lcd_string( const char *data )
{
    while( *data != '\0' )
 20c:	89 91       	ld	r24, Y+
 20e:	88 23       	and	r24, r24
 210:	e1 f7       	brne	.-8      	; 0x20a <lcd_string+0xe>
        lcd_data( *data++ );
}
 212:	df 91       	pop	r29
 214:	cf 91       	pop	r28
 216:	08 95       	ret

00000218 <lcd_generatechar>:
 
////////////////////////////////////////////////////////////////////////////////
// Schreibt ein Zeichen in den Character Generator RAM
 
void lcd_generatechar( uint8_t code, const uint8_t *data )
{
 218:	ef 92       	push	r14
 21a:	ff 92       	push	r15
 21c:	0f 93       	push	r16
 21e:	1f 93       	push	r17
 220:	cf 93       	push	r28
 222:	df 93       	push	r29
 224:	06 2f       	mov	r16, r22
 226:	17 2f       	mov	r17, r23
    // Startposition des Zeichens einstellen
    lcd_command( LCD_SET_CGADR | (code<<3) );
 228:	88 0f       	add	r24, r24
 22a:	88 0f       	add	r24, r24
 22c:	88 0f       	add	r24, r24
 22e:	80 64       	ori	r24, 0x40	; 64
 230:	7f df       	rcall	.-258    	; 0x130 <lcd_command>
 232:	e0 2e       	mov	r14, r16
 234:	e7 01       	movw	r28, r14
 236:	7e 01       	movw	r14, r28
 238:	f1 2e       	mov	r15, r17
 23a:	e7 01       	movw	r28, r14
 23c:	18 e0       	ldi	r17, 0x08	; 8
 
    // Bitmuster übertragen
    for ( uint8_t i=0; i<8; i++ )
    {
        lcd_data( data[i] );
 23e:	89 91       	ld	r24, Y+
 240:	69 df       	rcall	.-302    	; 0x114 <lcd_data>
 242:	11 50       	subi	r17, 0x01	; 1
{
    // Startposition des Zeichens einstellen
    lcd_command( LCD_SET_CGADR | (code<<3) );
 
    // Bitmuster übertragen
    for ( uint8_t i=0; i<8; i++ )
 244:	e1 f7       	brne	.-8      	; 0x23e <lcd_generatechar+0x26>
    {
        lcd_data( data[i] );
    }
}
 246:	df 91       	pop	r29
 248:	cf 91       	pop	r28
 24a:	1f 91       	pop	r17
 24c:	0f 91       	pop	r16
 24e:	ff 90       	pop	r15
 250:	ef 90       	pop	r14
 252:	08 95       	ret

00000254 <lcd_binaer>:

void lcd_binaer( uint16_t data )
{
 254:	0f 93       	push	r16
 256:	1f 93       	push	r17
 258:	df 93       	push	r29
 25a:	cf 93       	push	r28
 25c:	cd b7       	in	r28, 0x3d	; 61
 25e:	de b7       	in	r29, 0x3e	; 62
 260:	64 97       	sbiw	r28, 0x14	; 20
 262:	0f b6       	in	r0, 0x3f	; 63
 264:	f8 94       	cli
 266:	de bf       	out	0x3e, r29	; 62
 268:	0f be       	out	0x3f, r0	; 63
 26a:	cd bf       	out	0x3d, r28	; 61
	char Buffer[20];

	itoa( data, Buffer, 2 );
 26c:	8e 01       	movw	r16, r28
 26e:	0f 5f       	subi	r16, 0xFF	; 255
 270:	1f 4f       	sbci	r17, 0xFF	; 255
 272:	b8 01       	movw	r22, r16
 274:	42 e0       	ldi	r20, 0x02	; 2
 276:	50 e0       	ldi	r21, 0x00	; 0
 278:	51 d0       	rcall	.+162    	; 0x31c <itoa>
	lcd_string( Buffer ); // ggf. auch lcd_out() o.ä. in anderen Libraries
 27a:	c8 01       	movw	r24, r16
 27c:	bf df       	rcall	.-130    	; 0x1fc <lcd_string>
}
 27e:	64 96       	adiw	r28, 0x14	; 20
 280:	0f b6       	in	r0, 0x3f	; 63
 282:	f8 94       	cli
 284:	de bf       	out	0x3e, r29	; 62
 286:	0f be       	out	0x3f, r0	; 63
 288:	cd bf       	out	0x3d, r28	; 61
 28a:	cf 91       	pop	r28
 28c:	df 91       	pop	r29
 28e:	1f 91       	pop	r17
 290:	0f 91       	pop	r16
 292:	08 95       	ret

00000294 <lcd_integer>:

void lcd_integer( uint8_t data )
{
 294:	0f 93       	push	r16
 296:	1f 93       	push	r17
 298:	df 93       	push	r29
 29a:	cf 93       	push	r28
 29c:	cd b7       	in	r28, 0x3d	; 61
 29e:	de b7       	in	r29, 0x3e	; 62
 2a0:	64 97       	sbiw	r28, 0x14	; 20
 2a2:	0f b6       	in	r0, 0x3f	; 63
 2a4:	f8 94       	cli
 2a6:	de bf       	out	0x3e, r29	; 62
 2a8:	0f be       	out	0x3f, r0	; 63
 2aa:	cd bf       	out	0x3d, r28	; 61
	char Buffer[20];

	itoa( data, Buffer, 10 );
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	8e 01       	movw	r16, r28
 2b0:	0f 5f       	subi	r16, 0xFF	; 255
 2b2:	1f 4f       	sbci	r17, 0xFF	; 255
 2b4:	b8 01       	movw	r22, r16
 2b6:	4a e0       	ldi	r20, 0x0A	; 10
 2b8:	50 e0       	ldi	r21, 0x00	; 0
 2ba:	30 d0       	rcall	.+96     	; 0x31c <itoa>
	lcd_string( Buffer ); // ggf. auch lcd_out() o.ä. in anderen Libraries
 2bc:	c8 01       	movw	r24, r16
 2be:	9e df       	rcall	.-196    	; 0x1fc <lcd_string>
 2c0:	64 96       	adiw	r28, 0x14	; 20
 2c2:	0f b6       	in	r0, 0x3f	; 63
 2c4:	f8 94       	cli
 2c6:	de bf       	out	0x3e, r29	; 62
 2c8:	0f be       	out	0x3f, r0	; 63
 2ca:	cd bf       	out	0x3d, r28	; 61
 2cc:	cf 91       	pop	r28
 2ce:	df 91       	pop	r29
 2d0:	1f 91       	pop	r17
 2d2:	0f 91       	pop	r16
 2d4:	08 95       	ret

000002d6 <main>:
};



int main(void)
{
 2d6:	0f 93       	push	r16
 2d8:	1f 93       	push	r17
 2da:	df 93       	push	r29
 2dc:	cf 93       	push	r28
 2de:	cd b7       	in	r28, 0x3d	; 61
 2e0:	de b7       	in	r29, 0x3e	; 62
 2e2:	a8 97       	sbiw	r28, 0x28	; 40
 2e4:	0f b6       	in	r0, 0x3f	; 63
 2e6:	f8 94       	cli
 2e8:	de bf       	out	0x3e, r29	; 62
 2ea:	0f be       	out	0x3f, r0	; 63
 2ec:	cd bf       	out	0x3d, r28	; 61
	lcd_init();
 2ee:	36 df       	rcall	.-404    	; 0x15c <lcd_init>
	lcd_clear();
 2f0:	2c df       	rcall	.-424    	; 0x14a <lcd_clear>
	char* buf[20];

    const char *parray = (const char*) pgm_read_word (&getranke_namen[17]); // Lese die Adresse des i-ten Strings aus array[]
 2f2:	e8 e4       	ldi	r30, 0x48	; 72
 2f4:	f0 e0       	ldi	r31, 0x00	; 0
 2f6:	25 91       	lpm	r18, Z+
 2f8:	34 91       	lpm	r19, Z+
    strcpy_P (buf, parray); // Kopiere den Inhalt der Zeichenkette vom Flash ins RAM
 2fa:	8e 01       	movw	r16, r28
 2fc:	0f 5f       	subi	r16, 0xFF	; 255
 2fe:	1f 4f       	sbci	r17, 0xFF	; 255
 300:	c8 01       	movw	r24, r16
 302:	62 2f       	mov	r22, r18
 304:	73 2f       	mov	r23, r19
 306:	03 d0       	rcall	.+6      	; 0x30e <strcpy_P>
	lcd_string(buf); // Ausgabe des Textes 
 308:	c8 01       	movw	r24, r16
 30a:	78 df       	rcall	.-272    	; 0x1fc <lcd_string>
 30c:	ff cf       	rjmp	.-2      	; 0x30c <main+0x36>

0000030e <strcpy_P>:
 30e:	fb 01       	movw	r30, r22
 310:	dc 01       	movw	r26, r24
 312:	05 90       	lpm	r0, Z+
 314:	0d 92       	st	X+, r0
 316:	00 20       	and	r0, r0
 318:	e1 f7       	brne	.-8      	; 0x312 <strcpy_P+0x4>
 31a:	08 95       	ret

0000031c <itoa>:
 31c:	fb 01       	movw	r30, r22
 31e:	9f 01       	movw	r18, r30
 320:	e8 94       	clt
 322:	42 30       	cpi	r20, 0x02	; 2
 324:	bc f0       	brlt	.+46     	; 0x354 <itoa+0x38>
 326:	45 32       	cpi	r20, 0x25	; 37
 328:	ac f4       	brge	.+42     	; 0x354 <itoa+0x38>
 32a:	4a 30       	cpi	r20, 0x0A	; 10
 32c:	29 f4       	brne	.+10     	; 0x338 <itoa+0x1c>
 32e:	97 fb       	bst	r25, 7
 330:	1e f4       	brtc	.+6      	; 0x338 <itoa+0x1c>
 332:	90 95       	com	r25
 334:	81 95       	neg	r24
 336:	9f 4f       	sbci	r25, 0xFF	; 255
 338:	64 2f       	mov	r22, r20
 33a:	77 27       	eor	r23, r23
 33c:	1e d0       	rcall	.+60     	; 0x37a <__udivmodhi4>
 33e:	80 5d       	subi	r24, 0xD0	; 208
 340:	8a 33       	cpi	r24, 0x3A	; 58
 342:	0c f0       	brlt	.+2      	; 0x346 <itoa+0x2a>
 344:	89 5d       	subi	r24, 0xD9	; 217
 346:	81 93       	st	Z+, r24
 348:	cb 01       	movw	r24, r22
 34a:	00 97       	sbiw	r24, 0x00	; 0
 34c:	a9 f7       	brne	.-22     	; 0x338 <itoa+0x1c>
 34e:	16 f4       	brtc	.+4      	; 0x354 <itoa+0x38>
 350:	5d e2       	ldi	r21, 0x2D	; 45
 352:	51 93       	st	Z+, r21
 354:	10 82       	st	Z, r1
 356:	c9 01       	movw	r24, r18
 358:	00 c0       	rjmp	.+0      	; 0x35a <strrev>

0000035a <strrev>:
 35a:	dc 01       	movw	r26, r24
 35c:	fc 01       	movw	r30, r24
 35e:	67 2f       	mov	r22, r23
 360:	71 91       	ld	r23, Z+
 362:	77 23       	and	r23, r23
 364:	e1 f7       	brne	.-8      	; 0x35e <strrev+0x4>
 366:	32 97       	sbiw	r30, 0x02	; 2
 368:	04 c0       	rjmp	.+8      	; 0x372 <strrev+0x18>
 36a:	7c 91       	ld	r23, X
 36c:	6d 93       	st	X+, r22
 36e:	70 83       	st	Z, r23
 370:	62 91       	ld	r22, -Z
 372:	ae 17       	cp	r26, r30
 374:	bf 07       	cpc	r27, r31
 376:	c8 f3       	brcs	.-14     	; 0x36a <strrev+0x10>
 378:	08 95       	ret

0000037a <__udivmodhi4>:
 37a:	aa 1b       	sub	r26, r26
 37c:	bb 1b       	sub	r27, r27
 37e:	51 e1       	ldi	r21, 0x11	; 17
 380:	07 c0       	rjmp	.+14     	; 0x390 <__udivmodhi4_ep>

00000382 <__udivmodhi4_loop>:
 382:	aa 1f       	adc	r26, r26
 384:	bb 1f       	adc	r27, r27
 386:	a6 17       	cp	r26, r22
 388:	b7 07       	cpc	r27, r23
 38a:	10 f0       	brcs	.+4      	; 0x390 <__udivmodhi4_ep>
 38c:	a6 1b       	sub	r26, r22
 38e:	b7 0b       	sbc	r27, r23

00000390 <__udivmodhi4_ep>:
 390:	88 1f       	adc	r24, r24
 392:	99 1f       	adc	r25, r25
 394:	5a 95       	dec	r21
 396:	a9 f7       	brne	.-22     	; 0x382 <__udivmodhi4_loop>
 398:	80 95       	com	r24
 39a:	90 95       	com	r25
 39c:	bc 01       	movw	r22, r24
 39e:	cd 01       	movw	r24, r26
 3a0:	08 95       	ret

000003a2 <_exit>:
 3a2:	f8 94       	cli

000003a4 <__stop_program>:
 3a4:	ff cf       	rjmp	.-2      	; 0x3a4 <__stop_program>
